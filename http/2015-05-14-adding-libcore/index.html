<!DOCTYPE html>
<html>
	<head>
		<title>embedded.hannobraun.de</title>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<link href="/main.css" rel="stylesheet" type="text/css" media="all" />
	</head>

	<body>
		<main>
			<p class="date">2015-05-14</p>
			<h1>Adding libcore</h1>

			<p>
				In the
				<a href="/2015-05-08-translating-the-program-to-rust">last
				article</a>, we translated our C program to Rust. The resulting
				Rust code, however, was kind of a mess. It had to use weird
				intrinsic functions for basic tasks that simple operators would
				have been more suited for.
			</p>

			<p>
				As I explained back then, the reason for this is that the Rust
				language relies on its standard library for a lot of very basic
				features that in other languages have built into the language
				itself. And of course, we couldn't just use Rust's standard
				library, as that is designed to be run on top of an operating
				system.
			</p>

			<p>
				There is a solution though: While Rust's standard library looks
				like a monolithic block from the outside, it is actually very
				modular and built up from a few different libraries under the
				hood. The most basic of those is
				<a href="http://doc.rust-lang.org/nightly/core/index.html">libcore</a>.
				<code>libcore</code> provides many basic pieces of
				functionality, while being completely platform-agnostic. It
				doesn't even rely on such basic features as heap allocation,
				making it suitable for event the most constrained of embedded
				platforms.
			</p>

			<p>
				Before I show you how to use it though, I'd like to talk about
				my motivation here. So far, I've insisted on removing all
				third-party libraries and doing everything ourselves. Why not
				re-implement <code>libcore</code>, as we re-implemented all the
				hardware-specific code we were using?
			</p>

			<p>
				The answer to this question is pretty simple: Re-implementing
				<code>libcore</code> would teach us about Rust, but my goal here
				is to learn about the hardware. The libraries that we removed up
				till now formed a layer between us and the hardware.
				<code>libcore</code> is different, in that is provides us with
				tools to help write our code without obscuring in any way what
				is happening with the hardware. If any of you is interested in
				the inner workings of Rust, then writing your own
				<code>libcore</code> is probably a great project, but it's out
				of scope for what I'm doing here.
			</p>

			<p>
				Now that this is out of the way, let's get to our program:
			</p>

			<pre>
#![feature(core, intrinsics, lang_items, no_std)]

#![no_main]
#![no_std]
			</pre>

			<p>
				The only change in our header here is that <code>core</code> has
				been added to the list of features. <code>libcore</code> is
				still considered unstable, which means it might be changed in
				future versions. We need to declare the unstable features we
				need before the compiler lets us use
				them<a class="footnote" href="#note-1">[1]</a>.
			</p>

			<pre>
extern crate core;

use core::prelude::*;
			</pre>

			<p>
				Here we're declaring that we want to use <code>libcore</code>
				and import everything from its prelude. Normally, we have to
				include everything we'd like to use explicitly. The prelude
				contains those types and functions from <code>libcore</code>
				that are so essential that every program should have access to
				them.
			</p>

			<pre>
#[lang = "panic_fmt"]
pub extern fn panic_fmt() { loop {} }

#[lang = "stack_exhausted"]
pub extern fn stack_exhausted() { loop {} }

#[lang = "eh_personality"]
pub extern fn eh_personality() { loop {} }
			</pre>

			<p>
				These are functions that <code>libcore</code> uses, but doesn't
				define itself, mostly because it can't know the appropriate
				implementation. For example, code within <code>libcore</code>
				should be able to cause a program panic, but what that actually
				means depends on the platform. On a desktop operating system, a
				panicking process would print an error message and stop. For our
				case, just stopping the program (by looping forever) is good
				enough for now.
			</p>

			<pre>
#[no_mangle] pub extern fn __aeabi_unwind_cpp_pr0() { loop {} }
			</pre>

			<p>
				Unfortunately we still have to declare this mystery function.
				There's one important change to it: To make the function usable
				by code from <code>libcore</code>, it needs to be public (the
				<code>pub extern</code> bit).
			</p>

			<pre>
// This is the top of the stack, as provided to us by the linker.
extern {
	static _estack: u32;
}


// Type declaration for the vector table.
pub struct VectorTable {
	pub initial_stack_pointer_value: &amp;'static u32,
	pub reset_handler              : fn(),

	pub other_interrupt_vectors: [u32; 44],
}

unsafe impl Sync for VectorTable {}


// The actual vector table.
#[link_section=".vectors"]
pub static VECTOR_TABLE: VectorTable = VectorTable {
	initial_stack_pointer_value: &amp;_estack,
	reset_handler              : start,
	other_interrupt_vectors    : [0; 44],
};


// Addresses of several registers used to control parallel I/O.
const PB_PIO_ENABLE       : *mut u32 = 0x400E1000 as *mut u32;
const PB_OUTPUT_ENABLE    : *mut u32 = 0x400E1010 as *mut u32;
const PB_SET_OUTPUT_DATA  : *mut u32 = 0x400E1030 as *mut u32;
const PB_CLEAR_OUTPUT_DATA: *mut u32 = 0x400E1034 as *mut u32;

// Bit mask for PB27. This is pin 13 (the built-in LED) on the Arduino Due.
const PB27_MASK: u32 = 0x08000000;

// Addresses of several registers used to control the real-time timer.
const TIMER_MODE_REGISTER : *mut   u32 = 0x400E1A30 as *mut   u32;
const TIMER_VALUE_REGISTER: *const u32 = 0x400E1A38 as *const u32;
			</pre>

			<p>
				All of this is unchanged, so there's not a lot to say about it.
			</p>

			<pre>
// As the name suggests, this function sleeps for a given number of
// milliseconds. Our replacement for Arduino's delay function.
fn sleep_ms(milliseconds: u32) {
	unsafe {
		let sleep_until = *TIMER_VALUE_REGISTER + milliseconds;
		while *TIMER_VALUE_REGISTER &lt; sleep_until {}
	}
}
			</pre>

			<p>
				This is a nice example of what <code>libcore</code> does for us.
				After the translation from C, this function became really weird,
				having to use intrinsic compiler functions. Now with
				<code>libcore</code>, we can use operators like <code>+</code>
				and <code>&lt;</code> again.
			</p>

			<pre>
// This function is the entry point for our application and the handler
// function for the reset interrupt.
fn start() {
	unsafe {
		// Enable PB27 (pin 13) and configure it for output.
		*PB_PIO_ENABLE    = PB27_MASK;
		*PB_OUTPUT_ENABLE = PB27_MASK;

		// Set the timer to a resolution of a millisecond.
		*TIMER_MODE_REGISTER = 0x00000020;

		// Continuously set and clear output on PB27 (pin 13). This
		// blinks the Due's built-in LED, which is the single
		// purpose of this program.
		loop {
			*PB_SET_OUTPUT_DATA = PB27_MASK;
			sleep_ms(200);
			*PB_CLEAR_OUTPUT_DATA = PB27_MASK;
			sleep_ms(800);
		}
	}
}
			</pre>

			<p>
				And the rest of the program is also unchanged.
			</p>

			<p>
				Now that we have an updated program, we still need to build it.
				I'm developing on a x86-64 machine, so the <code>libcore</code>
				that comes with my installation of Rust has been compiled for
				that platform. This means, we're going to have to build it
				ourselves. Fortunately, this is pretty easy: Just clone the
				<a href="https://github.com/rust-lang/rust">Rust
				repository</a><a class="footnote" href="#note-2">[2]</a> and
				build it with the following
				command<a class="footnote" href="#note-3">[3]</a>:
			</p>

			<pre>
rustc \
	--target=target.json \
	-o output/libcore.rlib \
	vendor/rust/src/libcore/lib.rs
			</pre>

			<p>
				<code>target.json</code> refers to the
				<a href="https://github.com/hannobraun/embedded/blob/ccf9356da68cc50aa3595d9729212dcfdf7b8206/target.json">target
				specification from the last article</a>. Once
				<code>libcore</code> is compiled, we can build our program:
			</p>

			<pre>
rustc \
	--target=target.json \
	-C link-args="-Tlinker-script.ld" \
	-L output \
	-o output/blink.elf \
	blink/blink.rs
			</pre>

			<p>
				This one is essentially unchanged, except that we have to tell
				the Rust compiler to look in the <code>output</code> directory
				for libraries. The
				<a a href="https://github.com/hannobraun/embedded/blob/ccf9356da68cc50aa3595d9729212dcfdf7b8206/upload">rest
				of the program upload</a> is, yet again, unchanged.
			</p>

			<p>
				And that's it for today. As always, the full code is available
				<a href="https://github.com/hannobraun/embedded">on GitHub</a>.
				See you next time!
			</p>

			<hr />

			<footer>
				<a name="note-1"></a>
				<span class="footnote-number">[1]</span>
				<p>
					Please keep in mind that unstable features are not available
					in stable and beta versions of Rust, so you're going to have
					to use a nightly version.
				</p>

				<a name="note-2"></a>
				<span class="footnote-number">[2]</span>
				<p>
					If you're not familiar with
					<a href="http://git-scm.com/">Git</a>, the
					<a href="http://git-scm.com/book/en/v2/Git-Basics-Getting-a-Git-Repository">official
					documentation</a> seems like a good place to start.
				</p>

				<a name="note-3"></a>
				<span class="footnote-number">[3]</span>
				<p>
					In <a href="https://github.com/hannobraun/embedded">my
					repository</a>, I've added Rust as a submodule. I'm going to
					add an initialization script at some point, to make things
					more comfortable for anyone cloning the repository. For now,
					initializing the submodule is left as an exercise to the
					reader.
				</p>
			</footer>

			<hr />
		</main>

		<footer>
			<p>Made by <a href="http://hannobraun.de">Hanno Braun</a></p>
		</footer>
	</body>
</html>
